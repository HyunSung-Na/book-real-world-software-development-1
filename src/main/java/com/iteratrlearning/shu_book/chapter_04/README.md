# Chapter 4 문서 관리 시스템



#### 요구사항

문서 관리 시스템은 기존 환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환해야 한다. 세가지 형식의 문서를 다룬다.

1. 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문이다.
2. 우편물 : 특정 주소로 발송되는 텍스트 문서다.
3. 이미지 : 치아와 잇몸 엑스레이 사진을 저장한다. 용량이 크다.

또한 각각의 문서는 관리 대상 파일의 경로와 어떤 환자의 기록물인지를 나타내는 정보도 포함해야 한다. 예를 들어 본문에 "Joe Bloggs"를 포함하는 우편물 문서를 검색하면 그 결과를 반환해야 한다.



### 주요 이론



#### 리스코프 치환 원칙

클래스의 상속과 인터페이스 구현을 올바르게 사용하도록 도와준다. 

- 형식이라는 용어는 클래스나 인터페이스를 말한다.
- 하위 형식이라는 용어는 두 형식이 부모와 자식 관계를 이루었음을 의미한다. 즉 클래스의 상속이나 인터페이스 구현이 이에 해당한다.



##### 하위 형식에서 선행조건을 더할 수 없음

선행조건은 어떤 코드가 동작하는 조건을 결정한다. 우리는 구현한 코드가 어떻게든 실행될 것이라고 가정할 수는 없다. 예를 들어 Importer 구현은 임포트 하려는 파일이 존재하며, 읽을 수 있을 것이라는 선행조건을 갖는다.

- LSP란 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다. 예를 들어 부모가 문서의 크기를 제한하지 않았다면, 여러분은 문서의 크기가 100KB보다 작아야 한다고 요구할 수 없다.



##### 하위형식에서 후행조건을 약화시킬 수 없음

첫 번째 규칙하고 비슷해서 조금 헷갈릴 수 있다. 후행조건은 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다. 예를 들어 유효한 파일에 importFile()을 실행했다면 contents()가 반환하는 문서 목록에 그 파일이 반드시 포함되어야 한다. 즉 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.



##### 슈퍼형식의 불변자는 하위형식에서 보존됨

불변자란 밀물과 썰물처럼 항상 변하지 않는 어떤 것을 가리킨다. 상속 관계의 부모와 자식 클래스가 있을 때, 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.



##### 히스토리 규칙

LSP에서 가장 이해하기 어려운 개념 중 하나다. 기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다. 예제의 Document는 바꿀 수 없는 불변 클래스다. 즉 Document 클래스를 인스턴스화한 다음에는 어떤 속성도 삭제, 추가, 변경할 수 없다. 모든 부모 클래스의 사용자는 Document 클래스의 메서드를 호출했을 때 어떤 일이 일어날 수 있음을 인지하고 있기 때문이다. 만약 자식이 불변이 아니라면 호출자의 예상을 뒤엎을 것이다.



#### 기존 코드 확장과 재사용

소프트웨어는 항상 변한다. 시간이 흐르면서 제품에 기능을 추가하거나, 고객의 요구 사항이 바뀌거나, 법규가 제정되면서 소프트웨어를 어쩔 수 없이 변경해야 한다.

하나의 코드를 세 개의 임포트에 재사용할 수 있다면 좋을 것이다. 코드를 재사용하려면 먼저 이 코드를 어떤 클래스에 구현해야 한다. 다음과 같은 세 가지 방법 중 하나를 선택할 수 있는데, 각각의 장단점이 있다.

1. 유틸리티 클래스 사용
2. 상속 사용
3. 도메인 클래스 사용



##### 유틸리티 클래스 사용

가장 간단한 방법은 유틸리티 클래스를 만드는 것이다. ImportUtil 클래스를 만들어 여러 임포트에서 공유해야 하는 기능을 이 유틸리티 클래스에 구현한다. 유틸리티 클래스는 결국 여러 정적 메서드를 포함한다.

- 유틸리티 클래스는 그럭저럭 단순하고 쓸만하지만 객체지향 프로그래밍의 지향점과는 거리가 멀다. 
- 유틸리티 클래스는 보통 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다. 시간이 흐를수록 이는 갓 클래스의 모양을 갖춰간다. 즉 여러 의무를 담당하는 한 개의 거대 클래스가 탄생한다.



##### 상속 사용

상속은 다양한 환경에서 사용할 수 있는 완벽히 든든한 지원군이다. 리스코프 치환 원칙을 배울 때 상속 관계에서 제약을 올바르게 추가하는 방법도 배웠다. 실제 관계를 상속으로 잘못 설정하는 상황도 종종 발생한다.

- 이때 TextImporter는 Importer이며 이들은 LSP 규칙을 따르지만 뭔가 허전하다. 실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다는 점이 문제다. 시간이 흐르고 응용 프로그램이 바뀔 때, 응용프로그램을 그에 맞게 바꾸는 것보다는 변화를 추상화하는 것이 더 좋다. 일반적으로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다.



##### 도메인 클래스 사용

마지막으로 도메인 클래스로 텍스트 파일을 모델링하는 방법이 있다. 먼저 기본 개념을 모델링한 다음, 기본 개념이 제공하는 메서드를 호출해 다양한 임포터를 만든다.여기서 기본 개념이 뭘까? 예제에서는 TextFile은 Document의 서브클래스가 아니다. TextFile은 텍스트 파일이라는 기본 개념을 모델링하는 클래스로 텍스트 파일에서 데이터를 추출하는 메서드를 포함한다.

- 도메인 클래스를 이용하면 유연성을 개선할 수 있다고 생각해 이 책에서는 도메인 클래스로 임포터를 구현한다. 도메인 클래스를 이용하면 상속 같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다.



#### 테스트 위생

2장에서 배워듯이 자동화된 테스트를 구현하면 소프트웨어 유지보수에 큰 도움이 된다. 자동화된 테스트는 퇴행이 발생하는 범위를 줄이며 어떤 동작이 문제를 일으켰는지 이해할 수 있도록 도와준다. 또한 자동화된 테스트가 있으면 자신 있게 코드를 리펙토링할 수 있다. 하지만 테스트가 만병통치약은 아니다. 이런 호화를 누리려면 코드를 많이 구현해보고 유지보수해야 하기 때문이다.

- 테스트 유지보수 문제를 해결하려면 **테스트 위생**을 지켜야 한다. 테스트 위생이란 테스트 대상 코드베이스 뿐 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미한다. 테스트를 유지보수하지 않고 방치하면 시간이 지나면서 개발자의 생산성에 부담만 더해진다.



##### 테스트 이름 짓기

테스트를 만들려면 먼저 이름을 정해야 한다. 이름을 정할 때 개발자마다 특별한 규칙을 고집하기도 한다.

다음의 세 가지 모범 규칙을 적용해 테스트 이름을 짓는다.

- 도메인 용어 사용
  - 문제 도메인을 설명하거나 응용프로그램에서 문제를 지칭할 때 사용하는 용어를 테스트 이름에 사용한다.
- 자연어 사용
  - 모든 테스트 이름은 일반 문장처럼 쉽게 읽을 수 있어야 한다. 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사해야 한다.
- 서술적
  - 코드는 한 번 구현하면 여러 번 읽게 된다. 나중에 쉽게 읽을 수 있도록 애초에 시간을 들여 서술적인 좋은 이름을 붙이자. 좋은 이름이 생각나지 않으면 동료에게 도움을 받자. 이름이 짧다고 좋은 것이 아니다.



##### 구현이 아닌 동작

클래스, 컴포넌트, 시스템 테스트를 구현할 때는 대상의 **공개 동작**만 테스트한다. 테스트는 객체의 내부 상태나 설계는 고려하지 않고 오직 공개 API 메서드만 이용해 테스트를 수행해야 한다. 이를 지키지 않아 유지보수하기 어려운 테스트를 만드는 실수는 개발자들이 종종 저지르는 실수다.



##### 중복 배제

테스트 코드도 중복을 줄여야 한다. 안타깝게도 많은 개발자가 응용프로그램 코드에는 중복 코드를 사용하지 않으려 애쓰지만 테스트 코드의 중복 코드는 크게 신경 쓰지 않는다.



##### 좋은 진단

테스트는 실패하지 않으면 소용이 없다. 테스트가 시랲하지 않으면 테스트가 잘 동작하는지 알 수 없기 때문이다.

실패에 최적화된 테스트를 구현하는 것이 좋다. 여기서 말하는 최적화란 실패 했을 때 테스트를 더 빨리 실행할 수 있도록 만든다는 의미가 아니다. **테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 한다는 의미다.** 이때 좋은 진단을 활용한다.

- 진단이란 테스트가 실패했을 때 출력하는 메시지와 정보를 의미한다. 실패한 이유를 설명하는 메시지가 명확해야 쉽게 디버깅할 수 있다.



##### 오류 상황 테스트

테스트를 개발하면서 가장 흔히 저지르는 실수 중 하나는 응용프로그램의 가장 아름답고, 중요하며, 잘 동작하도록 예상된 경로만 검증하는 것이다. 문서 관리 시스템에 문서를 임포트할 때 다양한 문제가 발생할 수 있다. 존재하지 않는 파일이나 읽을 수 없는 파일이 임포트하려 시도하거나 텍스트를 추출하고 읽는 방법을 알 수 없는 파일을 임포트 할 수 있다.



- 아래 두 가지 테스트는 각각 문제가 발생하는 파일을 임포트한다. 제이유닛 @Test 애너테이션의 expected = 속성을 사용해 원하는 어셔션을 추가한다. 이 애너테이션은 **"제이유닛 씨, 이 테스트는 이런 종류의 예외를 던질 거예요"**라는 의미를 전달한다.



```java
	// 오류 상황 테스트

	@Test(expected = FileNotFoundException.class)
    public void shouldNotImportMissingFile() throws Exception {
        system.importFile("gobbledygook.txt");
    }

    @Test(expected = UnknownFileTypeException.class)
    public void shouldNotImportUnknownFile() throws Exception {
        system.importFile(RESOURCES + "unknown.txt");
    }
```

