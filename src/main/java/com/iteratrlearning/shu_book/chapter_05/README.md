# Chapter 5 비즈니스 규칙 엔진



### 비즈니스 규칙 엔진 요구 사항

- 비즈니스 규칙 엔진은 간단한 맞춤 언어를 사용해 한 개 이상의 비즈니스 규칙을 실행하는 소프트웨어로 다양한 컴포넌트를 동시에 지원한다.
- 팩트 : 규칙을 확인할 수 있는 정보
- 액션 : 수행하려는 동작
- 조건 : 액션을 언제 발생시킬지 지정
- 규칙 : 실행하려는 비즈니스 규칙을 지정, 보통 팩트, 액션, 조건을 한 그룹으로 묶어 규칙으로 만듦



비즈니스 규칙 엔진의 생산성과 관련된 좋은 점은 규칙이 기존의 응용프로그램과는 독립된 곳에서 실행, 유지보수, 테스트할 수 있다는 점이다.



### 테스트 주도 개발

5장에서는 테스트 주도 개발 방법으로 프로젝트를 진행한다. TDD 철학은 테스트 코드를 먼저 만든 후, 이에 맞춰 코드를 구현하는 것이다.



#### TDD를 사용하는 이유

다음과 같은 장점을 제공하기 때문에 사용한다.

1. 테스트르 ㄹ따로 구현하므로 테스트에 대응하는 요구 사항을 한 개씩 구현할 때마다 필요한 요구 사항에 집중하고 개선할 수 있다.
2. 코드를 올바르게 조직할 수 있다. 예를 들어 먼저 테스트를 구현하면서 코드에 어떤 공개 인터페이스를 만들어야 하는지 신중히 검토하게 된다.
3. TDD 주기에 따라 요구 사항 구현을 반복하면서 종합적인 테스트 스위트를 완성할 수 있으므로 요구사항을 만족시켰다는 사실을 조금 더 확신할 수 있으며 버그 발생 범위도 줄일 수 있다.
4. 테스트를 통과하기 위한 코드를 구현하기 때문에 필요하지 않은 테스트를 구현하는 일을 줄일 수 있다.



#### TDD 주기

TDD는 다음과 같은 주기를 따른다.

1. 실패하는 테스트 구현
2. 모든 테스트 실행
3. 기능이 동작하도록 코드 구현
4. 모든 테스트 실행



🚩 실생활에서는 코드를 항상 **리펙토링**해야 하며 그렇지 않으면 유지보수할 수 없는 코드가 되기 십상이다. 리펙토링하면 코드를 바꿨을 때 뭔가 잘못되어도 의지할 수 있는 테스트 스위트를 갖는다.





### 모킹

모킹은 run()이 실행되었을 때 이를 확인하는 기법으로, 자바의 모킹 라이브러리인 모키토를 이용한다.

1. Mock 생성
2. 메서드가 호출되었는지 확인



```java
	@Test
    public void shouldExecuteOneAction() {
        // given
        final BusinessRuleEngine businessRuleEngine = new BusinessRuleEngine();
        final Action mockAction = mock(Action.class);

        // when
        businessRuleEngine.addAction(mockAction);
        businessRuleEngine.run();

        // then
        verify(mockAction).execute();
    }
```

이런 식으로 mock 객체를 만들고 그 행동을 검증한다.



### 조건 추가하기



- 지역 변수 형식 추론

  자바 10은 지역 변수 추론 기능을 지원한다. **형식 추론**이란 컴파일러가 정적 형식을 자동으로 추론해 결정하는 기능으로 사용자는 더 이상 명시적으로 형식을 지정할 필요가 없다.



```java
// 명시적 형식 선언
Facts env = new Facts();
BusinessRuleEngine businessRuleEngine = new BusinessEngine(env);

// 지역 변수 형식 추론
var env = new Facts();
var businessRuleEngine = new BusinessRuleEngine(env);
```

형식 추론을 이용하면 자바 코드 구현 시간을 단축할 수 있다. 하지만 항상 이 기능을 사용해야 할까? 개발자는 코드를 구현하는 것보다 읽는 데 더 많은 시간을 소비한다는 사실을 기억하자.

⚡ 즉 코드를 쉽게 구현하는 것보다 코드를 쉽게 읽을 수 있느냐가 더 중요하다. var를 이용한 이득은 주관적이다. 따라서 var를 사용해서 가독성에 문제가 없다면 var를 사용하고 그렇지 않다면 var를 사용하지 않는 것이 좋다.



- switch 문

지금까지 액션이 한 가지 조건만 처리했다. 한 가지 조건으로는 처리하기 어려운 상황이 많다.

모든 조건 블록은 break문을 포함한다.(switch의 경우) break문은 switch문의 다음 블록이 실행되는 것을 방지한다. break를 실수로 빼먹으면 폴스루 모드로 실행된다.

이에 새로운 switch 문이 나오게 되었다.

```java
var forecastedAmount = amount * switch (dealStage) {
        case LEAD -> 0.2;
        case EVALUATING -> 0.5;
        case INTERESTED -> 0.8;
        case CLOSED -> 1;
}
```

새로운 switch를 이용하면 가독성이 좋아질 뿐만 아니라 모든 가능성을 확인하는 소모 검사도 이루어진다. 즉 enum에 switch를 사용하면 자바 컴파일러가 모든 enum값을 switch에서 소모했는지 확인한다.



##### 인터페이스 분리 원칙

어떤 클래스도 사용하지 않는 메서드에 의존성을 갖지 않아야 한다. 이는 불필요한 결합을 만들기 때문이다.

- 2장에서는 응집도를 촉진하는 단일 책임 원칙을 배웠다. SRP는 클래스가 한 개의 기능만 의무로 가져야 하며 클래스를 바꾸는 이유 역시 한 가지여야 한다는 일반적인 설계 가이드라인이다. ISP도 이 원칙과 비슷하게 들릴 수 있지만 관점이 다르다. ISP는 설계가 아닌 사용자 인터페이스에 초점을 둔다.
- 즉 인터페이스가 커지면 인터페이스 사용자는 결국 사용하지 않는 기능을 갖게 되며 이는 불필요한 결합도를 만든다.
- 인터페이스 분리 원칙을 따르려면 현재의 개념을 독자적인 작은 개념으로 쪼개야 한다. 이 원칙을 따르면 응집도도 높아진다.



### 플루언트 API 설계

사용자가 복잡한 조건을 포함하는 액션을 추가하는 기능을 성공적으로 제공했다. 이번에는 비즈니스 사용자의 도메인에 맞춰 단순하게 규칙을 추가하는 기능을 제공하려 한다. 빌더 패턴이란 무엇이며, 플루언트 API가 이 기능을 제공하는 데 어떤 도움을 주는지 배워본다.



#### 플로언트 API란

특정 문제를 더 직관적으로 해결할 수 있도록 특정 도메인에 맞춰진 API를 가리킨다. 플루언트 API의 메서드 체이닝을 이용하면 더 복잡한 연산도 지정할 수 있다. 여러분은 이미 몇가지 유명한 플루언트 API를 접해봤을 것이다.

- 자바 스트림에서는 문제를 실제로 해결하는 데 필요한 언어를 자용하는 것처럼 데이터 처리 쿼리를 지정한다.
- 스프링 통합은 엔터프라이즈 통합 패턴 도메인에 가까운 어휘로 엔터프라이즈 통합 패턴을 지정하는 자바 API를 제공한다.
- jooq는 직관적 API로 다양한 데이터베이스와 상호작용하는 기능을 제공하는 라이브러리다.



#### 도메인 모델링

도메인 에서는 세 가지 개념이 등장한다.

- 조건 : 어떤 팩트에 적용할 조건
- 액션 : 실행할 연산이나 코드 집합
- 규칙 : 조건과 액션을 합친 것, 조건이 참일 때만 액션을 실행한다.



#### 빌더 패턴

- 빌더 패턴은 단순하게 객체를 만드는 방법을 제공한다. 빌더 패턴은 생성자의 파라미터를 분해해서 각각의 파라미터를 받는 여러 메서드로 분리한다. 덕분에 각 메서드는 도메인이 다루는 문제와 비슷한 이름을 갖는다. 예를 들어 when, then이라는 용어를 사용하려 한다.
- 또한 사용자가 명시적으로 생성자를 호출하지 못하도록 생성자를 비공개로 설정한다. 그러려면 API에 다른 진입점을 만들어야 한다.
- when() 메서드를 정적 메서드로 만들어 이 메서드를 사용자가 직접 호출하면 예전 생성자를 호출하도록 한다. 게다가 정적 메서드를 제공하므로 Rule 객체를 설정하려면 어떤 메서드를 이용해야 하는지 쉽게 알 수 있으므로 발견성도 개선된다.
- then() 메서드가 DefaultRule 객체의 최종 생성을 책임진다.



### 총정리

- 테스트 주도 개발 철학에 따르면 먼저 테스트를 구현하고 이를 가이드 삼아 코드를 구현한다.
- 모킹으로 유닛 테스트에서 어떤 동작이 실행되었는지 확인한다.
- 자바는 지역 변수 형식 추론과 switch문을 지원한다.
- 빌더 패턴은 복잡한 객체를 사용자 친화적인 API로 인스턴스화할 수 있도록 돕는다.
- 인터페이스 분리 원칙은 불필요한 메서드의 디펜던시를 감소시켜 높은 응집도를 촉진한다. 큰 인터페이스를 응집력 있는 작은 인터페이스로 분리해 사용자는 필요한 기능만 사용할 수 있다.



